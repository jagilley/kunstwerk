For any given Spotify track - what's the most automatic way you can think of of finding the "auto-generated by YouTube" version of it? I'd like to do this programmatically if possible


ChatGPT said:

Thought for 1m 6s
Below is the workflow that, in practice, has given me the highest hit‑rate while staying 100 % automatic.
It is split into two layers so you can choose the one that matches the effort you want to spend:

1. One‑call solution (Odesli / Song.link API)

What you do	Why it works
Send GET https://api.song.link/v1-alpha.1/links?url=https://open.spotify.com/track/{SPOTIFY_ID}	Odesli looks the track up on every major DSP and returns a JSON blob that already contains the YouTube and YouTube Music URLs it found for the ISRC.​
Songlink/Odesli
GitHub
Parse the JSON → linksByPlatform.youtube.url (or youtubeMusic)	For the vast majority of mainstream releases this URL points to the “Artist ‑ Topic” auto‑generated video (the art‑track).
Pros

Zero auth or keys, just an HTTPS call.

Handles the occasional re‑title, alternate artist name spellings, etc.

Very fast (single request).

Cons

Coverage isn’t perfect for very new indie uploads (Odesli’s crawler lags ~24 h).

You get a YouTube link, but not the confidence score or extra metadata that a bespoke search gives you.

Try it now
curl "https://api.song.link/v1-alpha.1/links?url=https://open.spotify.com/track/1jJci4qxiYcOHhQR247rEU"
and scroll to linksByPlatform.youtube.url.

2. DIY lookup with the YouTube Data API
When you want more control (or Odesli misses a track) the recipe below is still 100 % automatic but lets you tune ranking rules.

2‑step pipeline

Step	Endpoint & parameters	Notes
① Grab the ISRC from Spotify	GET https://api.spotify.com/v1/tracks/{id} → external_ids.isrc	Spot‑on unique identifier.​
Spotify for Developers
② Search YouTube for that ISRC	GET https://youtube.googleapis.com/youtube/v3/search
?part=snippet
&q=isrc%3A{ISRC}
&type=video
&videoCategoryId=10	The public Search endpoint accepts isrc:XXXX in the query string even though it is not documented. It tends to return the art‑track first.​
Google for Developers
Stack Overflow
Post‑filtering heuristics
After you get a list of candidate video IDs, call videos.list with part=snippet,contentDetails and keep the first item that matches all of:

snippet.channelTitle ends with "‑ Topic" or
snippet.description contains "Auto-generated by YouTube"
(hallmark of Topic channels).​
Support | Amuse

contentDetails.duration within ±2 s of the Spotify track length.

(Optional) audioQuality = AUDIO_QUALITY_MEDIUM for art‑tracks.

Minimal Python example
python
Copy
Edit
import os, requests, time

SPOTIFY_ID   = "1jJci4qxiYcOHhQR247rEU"          # demo: Ed Sheeran – Shape of You
SPOTIFY_TOKEN = os.environ["SPOTIFY_TOKEN"]
YOUTUBE_KEY   = os.environ["YOUTUBE_KEY"]

# 1. Spotify → ISRC, duration
t = requests.get(f"https://api.spotify.com/v1/tracks/{SPOTIFY_ID}",
                 headers={"Authorization": f"Bearer {SPOTIFY_TOKEN}"}).json()
isrc       = t["external_ids"]["isrc"]
duration_s = t["duration_ms"] // 1000

# 2. YouTube search by ISRC
search = requests.get(
    "https://youtube.googleapis.com/youtube/v3/search",
    params={
        "part": "snippet",
        "q": f"isrc:{isrc}",
        "type": "video",
        "videoCategoryId": 10,
        "key": YOUTUBE_KEY
    }).json()

for item in search["items"]:
    vid = item["id"]["videoId"]
    meta = requests.get(
        "https://youtube.googleapis.com/youtube/v3/videos",
        params={"part": "snippet,contentDetails", "id": vid, "key": YOUTUBE_KEY}
    ).json()["items"][0]

    ch  = meta["snippet"]["channelTitle"]
    dur = time.strptime(meta["contentDetails"]["duration"], "PT%MM%SS")
    dur_s = dur.tm_min*60 + dur.tm_sec

    if ch.endswith(" - Topic") and abs(dur_s - duration_s) < 2:
        print("Auto‑generated video is", f"https://youtu.be/{vid}")
        break
Pros & cons
*✔️ Full control, can attach your own ranking/ML model.
*❌ Requires a YouTube Data API key and costs 100 quota units per search.

Which path should I pick?

If you …	Use
“Good enough, one request, no keys”	Odesli
Need strict guarantees, metadata, or logging view counts yourself	YouTube Data API + ISRC search
Both options remain fully programmatic and need no manual intervention once wired up.

Happy mapping!







Sources






You said:
Perfect, Solution #1 works great! The only caveat is that it works better for individual Spotify tracks than albums - there's no YouTube link for the album itself that gets returned from the API. But it does successfully retrieve the canonical YouTube link for each song in the album. Can you think of an easy way to grab a Spotify Album or playlist and call the API for each song therein?


ChatGPT said:

Thought for 26 seconds
Below is the simplest end‑to‑end pattern I use in production to “explode” any Spotify album or playlist URL into its constituent track URLs and pipe each one through the same Odesli call that worked for you on single tracks.

1 · Pull the list of track IDs from Spotify
text
Copy
Edit
Album →  GET https://api.spotify.com/v1/albums/{album_id}/tracks
Playlist → GET https://api.spotify.com/v1/playlists/{playlist_id}/tracks
These endpoints are public‑scope; a Client‑Credentials token is enough.
Both return up to 100 items per page, so loop on next until it is null.​
Spotify for Developers
Spotify for Developers

Tiny helper (Python ≥ 3.11, no external deps)
python
Copy
Edit
import os, requests, re, itertools

SPOTIFY_TOKEN = os.environ["SPOTIFY_TOKEN"]       # client‑credentials
SPOTIFY_BASE  = "https://api.spotify.com/v1"

def chunks(it, size):           # quick batching helper
    it = iter(it)
    while (batch := list(itertools.islice(it, size))):
        yield batch

def fetch_tracks(url: str) -> list[str]:
    """
    Accepts any Spotify *album* or *playlist* URL/URI and
    returns the list of track IDs it contains.
    """
    m = re.search(r"(album|playlist)[/:]([0-9A-Za-z]+)", url)
    if not m:
        raise ValueError("Not an album or playlist URL")
    kind, _id = m.groups()

    header = {"Authorization": f"Bearer {SPOTIFY_TOKEN}"}
    endpoint = f"{SPOTIFY_BASE}/{kind}s/{_id}/tracks"
    params   = {"limit": 100}

    ids = []
    while endpoint:
        page = requests.get(endpoint, headers=header, params=params).json()
        ids.extend(t["track"]["id"] if kind == "playlist" else t["id"]
                    for t in page["items"] if t["track" if kind == "playlist" else None])
        endpoint = page.get("next")
        params = None                # only needed on first call
    return ids
fetch_tracks() now gives you a flat list of Spotify track IDs for an album or playlist of any length.

2 · Fire the Odesli request for each track
python
Copy
Edit
def odesli_youtube(track_id: str) -> str | None:
    url = f"https://api.song.link/v1-alpha.1/links?url=https://open.spotify.com/track/{track_id}"
    try:
        info = requests.get(url, timeout=4).json()
        return info["linksByPlatform"]["youtube"]["url"]
    except Exception:
        return None
Parallelising to stay fast
Odesli is light but sequential calls add up for big playlists.
The cleanest speed‑up is to batch with concurrent.futures:

python
Copy
Edit
from concurrent.futures import ThreadPoolExecutor

def youtube_for_collection(spotify_url: str) -> dict[str, str | None]:
    ids = fetch_tracks(spotify_url)
    with ThreadPoolExecutor(max_workers=16) as pool:
        yt_urls = list(pool.map(odesli_youtube, ids))
    return dict(zip(ids, yt_urls))
youtube_for_collection() returns a mapping
{ spotify_track_id : youtube_art_track_url | None } in one shot.

One‑liner shell version (for quick hacks)
bash
Copy
Edit
SPOTIFY_URL="https://open.spotify.com/playlist/37i9dQZF1DWXRqgorJj26U"

curl -s -H "Authorization: Bearer $SPOTIFY_TOKEN" \
     "$(curl -sI "$SPOTIFY_URL" | grep -oE 'playlist/[0-9A-Za-z]+' | sed 's|playlist/||')" | \
jq -r '.items[].track.id' | \
xargs -I{} -P16 curl -s "https://api.song.link/v1-alpha.1/links?url=https://open.spotify.com/track/{}" |
jq -r '.linksByPlatform.youtube.url'
(Requires jq and GNU xargs for -P parallelism.)

3 · Putting it together
Input Album or playlist link your user drops in.

Process fetch_tracks() → per‑track Odesli lookup (threaded).

Output Hand back either:

array of YouTube art‑track URLs in the original order, or

JSON map if you need to merge with other metadata.

Because you stay inside the sanctioned Spotify Web API and make only normal public Odesli calls, the whole flow is TOS‑safe and deploys on any serverless function without headaches.

Happy linking!



Sources






You said:
Wait, and how can I get a Spotify client-credentials token? Is this part of the developer API that they rolled back access to in the fall of 2024?


ChatGPT said:

Thought for 39 seconds
Getting a client‑credentials token in 3 minutes
Create (or open) an app in the Developer Dashboard

Visit https://developer.spotify.com/dashboard and log in.

Click “Create app”, give it any name/description, and accept the T & Cs.

On the app page copy the Client ID and click “View client secret” to reveal the Client Secret.
(Those two strings are all you need for the client‑credentials flow.) 
Spotify for Developers

Exchange the ID + secret for an access token

bash
Copy
Edit
# Unix‑ish one‑liner
curl -s -X POST \
     -H "Authorization: Basic $(printf '%s:%s' "$SPOTIFY_CLIENT_ID" "$SPOTIFY_CLIENT_SECRET" | base64)" \
     -d grant_type=client_credentials \
     https://accounts.spotify.com/api/token
The response JSON contains:

json
Copy
Edit
{
  "access_token": "BQDhL...rVnw",
  "token_type": "Bearer",
  "expires_in": 3600
}
Grab the access_token and include it on every Web API call:

bash
Copy
Edit
GET https://api.spotify.com/v1/albums/{id}/tracks
Authorization: Bearer BQDhL...rVnw
(Tokens last 1 hour; just repeat step 2 when they expire.)

Or let a library do it

python
Copy
Edit
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials

sp = spotipy.Spotify(
        client_credentials_manager=SpotifyClientCredentials(
            client_id     = "YOUR_ID",
            client_secret = "YOUR_SECRET"))

tracks = sp.album_tracks("4aawyAB9vmqN3uQ7FjRGTy")   # example album ID
“Didn’t Spotify lock things down in late 2024?”
Yes and no:

On 27 Nov 2024 Spotify removed specific high‑value endpoints (Related Artists, Recommendations, Audio Features/Analysis, Featured Playlists, etc.) for new apps that are still in development mode (≤ 25 test users). Production apps created before that date were grandfathered. 
Spotify for Developers

The core catalog endpoints we’re using here—/albums, /playlists, /tracks, and search—are still open to the client‑credentials flow because they don’t expose personal user data or algorithmic signals.

So for your use‑case (just enumerating albums/playlists → per‑track YouTube links) the standard client‑credentials flow remains fully functional.

If you ever bump into a 403 or missing data, double‑check that you’re not hitting one of the newly restricted endpoints listed in the November‑2024 blog post; otherwise you’re good to go. 
The Verge

TL;DR
Register an app → POST to /api/token with grant_type=client_credentials → use the returned bearer token in the Authorization header. None of the 2024 rollback affects these basic metadata calls.




Sources






